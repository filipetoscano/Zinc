using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;

namespace Zinc.WebService.ServiceUtil
{
    /// <summary />
    public class Program
    {
        /// <summary />
        public static int Main( string[] args )
        {
            /*
             * 
             */
            CommandLine cl = new CommandLine();

            for ( int i = 0; i < args.Length; i++ )
            {
                string arg = args[ i ];

                if ( arg == "-d" || arg == "--delete-input" )
                {
                    cl.InputDelete = true;
                    continue;
                }

                if ( arg == "-a" || arg == "--shrink-attributes" )
                {
                    cl.ShrinkAttributes = true;
                    continue;
                }

                if ( arg == "-n" || arg == "--shrink-namespaces" )
                {
                    cl.ShrinkNamespaces = true;
                    continue;
                }

                if ( arg == "-p" || arg == "--shrink-properties" )
                {
                    cl.ShrinkProperties = true;
                    continue;
                }

                if ( arg == "-o" )
                {
                    cl.OutputFile = args[ ++i ];
                    continue;
                }

                if ( arg.StartsWith( "--output=" ) == true )
                {
                    cl.OutputFile = arg.Substring( "--output=".Length );
                    continue;
                }

                if ( arg.StartsWith( "-" ) == true || arg.StartsWith( "+" ) == true )
                    continue;

                cl.InputFiles.Add( arg );
            }


            if ( cl.OutputFile == null )
            {
                Console.Error.WriteLine( "error: output file not specified." );
                return 1;
            }

            if ( cl.InputFiles.Count == 0 )
            {
                Console.Error.WriteLine( "error: at least one input file must be specified." );
                return 2;
            }

            if ( cl.HasShrink == true )
            {
                Console.Write( "shrink:" );

                if ( cl.ShrinkAttributes == true )
                    Console.Write( " attributes" );

                if ( cl.ShrinkNamespaces == true )
                    Console.Write( " namespaces" );

                if ( cl.ShrinkProperties == true )
                    Console.Write( " properties" );

                Console.WriteLine();
            }


            /*
             * 
             */
            List<TypeDefinition> types = new List<TypeDefinition>();
            string ns = null;


            /*
             * 
             */
            foreach ( string filename in cl.InputFiles )
            {
                Console.Write( "parsing {0}... ", filename );

                if ( File.Exists( filename ) == false )
                {
                    Console.WriteLine( "error" );
                    Console.Error.WriteLine( "error: file '{0}' does not exist.", filename );
                    return 3;
                }

                var f = ParseFile( filename );

                Console.WriteLine( "{0} types found, OK", f.Types.Count );

                foreach ( var t in f.Types )
                {
                    if ( types.Where( x => x.Name == t.Name ).Count() == 0 )
                        types.Add( t );
                }

                if ( ns == null )
                    ns = f.Namespace;
            }


            /*
             * 
             */
            StringBuilder sb = new StringBuilder();
            sb.AppendLine( "/// <auto-generated>" );
            sb.AppendLine( "/// This code has been automatically generated by a tool." );
            sb.AppendLine( "/// Changes to this file will be lost when the code is regenerated." );
            sb.AppendLine( "/// </auto-generated>" );
            sb.AppendLine( "using System;" );
            sb.AppendLine( "using System.CodeDom.Compiler;" );
            sb.AppendLine( "using System.ComponentModel;" );
            sb.AppendLine( "using System.Diagnostics;" );
            sb.AppendLine( "using System.ServiceModel;" );
            sb.AppendLine( "using System.Xml.Serialization;" );
            sb.AppendLine( "using FWK = Zinc.WebServices.Client;" );
            sb.AppendLine( "using SVC = " + ns + ";" );
            sb.AppendLine( "" );
            sb.AppendLine( "namespace " + ns );
            sb.AppendLine( "{" );

            foreach ( var t in types.OrderBy( x => x.TypeType ).ThenBy( x => x.Name ) )
            {
                sb.Append( t.Definition );
                sb.AppendLine();
            }

            sb.AppendLine( "}" );


            /*
             * These three classes are 'framework', since all web services
             * developed using .WebServices generators will make use of them.
             */
            sb.Replace( ns + ".EndpointHeader", "FWK.EndpointHeader" );
            sb.Replace( ns + ".ExecutionHeader", "FWK.ExecutionHeader" );
            sb.Replace( ns + ".ActorFault", "FWK.ActorFault" );
            sb.Replace( " ActorError ", " FWK.ActorFault " );
            sb.Replace( " ActorError[] ", " FWK.ActorFault[] " );

            int fullSize = sb.Length;


            /*
             * Shrink the attribute namespaces! It is understandable that, in order
             * to avoid collision, we use full-namespaces. But, if in our projects,
             * somebody declares a custom class named e.g. 'SerializableAttribute',
             * then they deserve the wrath and punishment coming their way! >:-f
             */
            if ( cl.ShrinkAttributes == true )
            {
                sb.Replace( "[System.SerializableAttribute()]", "[Serializable]" );
                sb.Replace( "[System.CodeDom.Compiler.GeneratedCodeAttribute(", "[GeneratedCode(" );
                sb.Replace( "[System.ComponentModel.DesignerCategoryAttribute(", "[DesignerCategory(" );
                sb.Replace( "[System.ComponentModel.EditorBrowsableAttribute(System.ComponentModel.EditorBrowsableState.Advanced)]", "[EditorBrowsable(EditorBrowsableState.Advanced)]" );
                sb.Replace( "[System.Diagnostics.DebuggerStepThroughAttribute()]", "[DebuggerStepThrough]" );
                sb.Replace( "[System.Xml.Serialization.XmlArrayAttribute(", "[XmlArray(" );
                sb.Replace( "[System.Xml.Serialization.XmlElementAttribute(", "[XmlElement(" );
                sb.Replace( "[System.Xml.Serialization.XmlTypeAttribute(", "[XmlType(" );
                sb.Replace( "[System.Xml.Serialization.XmlRootAttribute(", "[XmlRoot(" );
                sb.Replace( "[System.ServiceModel.FaultContractAttribute(", "[FaultContract(" );
                sb.Replace( "[System.ServiceModel.MessageBodyMemberAttribute(", "[MessageBodyMember(" );
                sb.Replace( "[System.ServiceModel.MessageContractAttribute(", "[MessageContract(" );
                sb.Replace( "[System.ServiceModel.MessageHeaderAttribute(", "[MessageHeader(" );
                sb.Replace( "[System.ServiceModel.OperationContractAttribute(", "[OperationContract(" );
                sb.Replace( "[System.ServiceModel.ServiceContractAttribute(", "[ServiceContract(" );
                sb.Replace( "[System.ServiceModel.XmlSerializerFormatAttribute()]", "[XmlSerializerFormat]" );
            }

            string content = sb.ToString();


            /*
             * When svcutil generates the proxy, it fully prefixes *all* classes -- even
             * if they are defined in the same namespace. Therefore, we want to replace
             * all of this by the namespace alias -- but we need to be careful, because
             * the namespace also appears in the [ServiceContract/@ConfigurationName].
             * In order to not replace it, we make use of a reverse lookup to exclude any
             * use which starts with ".
             */
            if ( cl.ShrinkNamespaces == true )
            {
                Regex r3 = new Regex( "(?<=[^\"])" + ns.Replace( ".", "\\." ) + "\\." );
                content = r3.Replace( content, "SVC." );
            }


            /*
             * Rather than using properties with backing members, use the short-hand
             * property syntax. The first regexp converts the getter/setter, while the
             * second regexp removes the backing member.
             */
            if ( cl.ShrinkProperties == true )
            {
                Regex r1 = new Regex( "get(.*?)}(.*?)}", RegexOptions.Multiline | RegexOptions.Singleline );
                content = r1.Replace( content, "get; set;" );

                Regex r2 = new Regex( @"\s+private(.*?);", RegexOptions.Multiline );
                content = r2.Replace( content, "" );
            }


            /*
             * Success!
             */
            int currentSize = content.Length;

            if ( cl.HasShrink == true )
                Console.Write( "writing '{0}' ({1} bytes, {3:0}% from original {2} bytes)... ", cl.OutputFile, currentSize, fullSize, 100.0m * currentSize / fullSize );
            else
                Console.Write( "writing '{0}'... ", cl.OutputFile );

            File.WriteAllText( cl.OutputFile, content );
            Console.WriteLine( "OK" );


            /*
             * Do we remove the source files? This is meant to encourage not leaving
             * temporary files around in the filesystem, lest they get added to source
             * control by mistake.
             */
            if ( cl.InputDelete == true )
            {
                Console.Write( "deleting input files" );

                foreach ( string filename in cl.InputFiles )
                {
                    try
                    {
                        Console.Write( "." );
                        File.Delete( filename );
                    }
                    catch
                    {
                    }
                }

                Console.WriteLine( " OK" );
            }

            return 0;
        }


        private static ServiceFile ParseFile( string filename )
        {
            #region Validations

            if ( filename == null )
                throw new ArgumentNullException( "filename" );

            #endregion

            string[] lines = File.ReadAllLines( filename );

            StringBuilder sb = new StringBuilder();

            Dictionary<string, TypeDefinition> types = new Dictionary<string, TypeDefinition>();
            string state = "NS";
            string ns = null;
            TypeDefinition typeDef = null;

            List<string> fwkTypes = new List<string>();
            fwkTypes.Add( "ActorError" );
            fwkTypes.Add( "ActorFault" );
            fwkTypes.Add( "EndpointHeader" );
            fwkTypes.Add( "ExecutionHeader" );


            /*
             * 
             */
            foreach ( string line in lines )
            {
                switch ( state )
                {
                    case "NS":
                        if ( line.StartsWith( "namespace " ) == true )
                        {
                            ns = line.Substring( "namespace ".Length );
                            state = "NONE";
                        }
                        break;


                    case "NONE":
                        if ( line.Trim().StartsWith( "[" ) == true )
                            sb.AppendLine( line );

                        if ( line.Contains( "System.Xml.Serialization.XmlTypeAttribute(Namespace=" ) == true )
                        {
                            int ix = line.IndexOf( "Attribute(Namespace=" ) + "Attribute(Namespace=".Length + 1;
                            int jx = line.IndexOf( "\")]", ix );

                            string rns = line.Substring( ix, jx - ix );
                            string n = "    [System.Xml.Serialization.XmlRootAttribute(Namespace=\"" + rns + "\")]";
                            sb.AppendLine( n );
                        }

                        if ( line.StartsWith( "    public" ) == true )
                        {
                            sb.AppendLine( line );
                            typeDef = ExtractTypeDef( line );
                            state = "TYPE";
                        }
                        break;


                    case "TYPE":
                        if ( line == "    }" )
                        {
                            sb.AppendLine( line );
                            state = "NONE";

                            typeDef.Definition = sb.ToString();

                            if ( fwkTypes.Contains( typeDef.Name ) == false )
                                types.Add( typeDef.Name, typeDef );

                            sb = new StringBuilder();
                            typeDef = null;
                        }
                        else
                        {
                            sb.AppendLine( line.TrimEnd() );
                        }
                        break;
                }
            }


            /*
             * 
             */
            ServiceFile f = new ServiceFile()
            {
                Filename = filename,
                Namespace = ns,
                Types = types.Values.ToList()
            };

            return f;
        }


        private static TypeDefinition ExtractTypeDef( string line )
        {
            #region Validations

            if ( line == null )
                throw new ArgumentNullException( "line" );

            #endregion

            TypeDefinition td = new TypeDefinition();

            Regex r1 = new Regex( "public (partial )?(?<type>interface|class|enum) (?<name>\\w+)" );
            Match m = r1.Match( line );


            /*
             * 
             */
            string t = m.Groups[ "type" ].Value;

            if ( t == "interface" )
                td.TypeType = TypeofType.Interface;
            else if ( t == "enum" )
                td.TypeType = TypeofType.UserType;
            else if ( line.Contains( "System.ServiceModel.ClientBase<" ) == true )
                td.TypeType = TypeofType.ClientClass;
            else
                td.TypeType = TypeofType.UserType;


            /*
             * 
             */
            td.Name = m.Groups[ "name" ].Value;

            return td;
        }
    }
}
