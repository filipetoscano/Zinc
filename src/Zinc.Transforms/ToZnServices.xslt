<?xml version="1.0" encoding="utf-8"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:msxsl="urn:schemas-microsoft-com:xslt"
    xmlns:zn="urn:zinc"
    xmlns:rest="urn:zinc/rest"
    xmlns:v="urn:zinc/validation"
    xmlns:eo="urn:eo-util"
    exclude-result-prefixes="msxsl zn rest eo">

    <xsl:param name="FileName" />
    <xsl:param name="Namespace" />
    <xsl:param name="UriDirectory" />

    <xsl:output method="text" indent="yes" />

    <xsl:variable name="fwk-ns" select=" 'urn:zinc' " />
    <xsl:variable name="NewLine">
        <xsl:text>
</xsl:text>
    </xsl:variable>


    <!-- ================================================================
    ~
    ~ zn:services
    ~
    ================================================================= -->
    <xsl:template match=" zn:services ">
        <xsl:text>// autogenerated: do NOT edit manually / do NOT commit to source control
using Platinum;
using Platinum.Mock;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Web;
using System.Web.Http;
using System.ServiceModel;
using Zinc.WebServices;

</xsl:text>
        <xsl:text>namespace </xsl:text>
        <xsl:value-of select=" $Namespace " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>{</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" not( zn:rest/@enabled = 'false' ) ">
            <xsl:apply-templates select=" zn:service " mode="rest">
                <xsl:sort select=" @name" data-type="text" />
            </xsl:apply-templates>
        </xsl:if>
        <xsl:value-of select=" $NewLine " />
        <xsl:apply-templates select=" zn:service " mode="wcf">
            <xsl:sort select=" @name" data-type="text" />
        </xsl:apply-templates>

        <xsl:text>}</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>


    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ zn:services/zn:method
    ~ REST service
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template match=" zn:service " mode="rest">
        <xsl:text>    /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    public partial class </xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Controller : ApiController</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:apply-templates select=" zn:method " mode="rest">
            <xsl:sort select=" @name" data-type="text" />
        </xsl:apply-templates>

        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" position() != last() ">
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>

    <xsl:template match=" zn:method " mode="rest">
        <xsl:variable name="ns">
            <xsl:value-of select=" ../@name " />
            <xsl:text>Service</xsl:text>
        </xsl:variable>

        <xsl:variable name="fname">
            <xsl:value-of select=" $UriDirectory " />
            <xsl:text>/</xsl:text>
            <xsl:value-of select=" $ns " />
            <xsl:text>/</xsl:text>
            <xsl:value-of select=" @name " />
            <xsl:text>.xml</xsl:text>
        </xsl:variable>

        <xsl:variable name="zn:method" select=" document( $fname )/zn:method " />

        <xsl:choose>
            <xsl:when test=" not( $zn:method/zn:request/@rest:method ) or $zn:method/zn:request/@rest:method = 'post' ">
                <xsl:call-template name="rest-post">
                    <xsl:with-param name="ns" select=" $ns " />
                    <xsl:with-param name="zn:method" select=" $zn:method " />
                </xsl:call-template>
            </xsl:when>

            <xsl:when test=" $zn:method/zn:request/@rest:method = 'get' ">
                <xsl:call-template name="rest-post">
                    <xsl:with-param name="ns" select=" $ns " />
                    <xsl:with-param name="zn:method" select=" $zn:method " />
                </xsl:call-template>
                <xsl:value-of select=" $NewLine " />

                <xsl:call-template name="rest-get">
                    <xsl:with-param name="ns" select=" $ns " />
                    <xsl:with-param name="zn:method" select=" $zn:method " />
                </xsl:call-template>
            </xsl:when>
        </xsl:choose>

        <xsl:if test=" position() != last() ">
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>

    <xsl:template name="rest-post">
        <xsl:param name="ns" />
        <xsl:param name="zn:method" />

        <!-- Documentation -->
        <xsl:text>        /// &lt;summary&gt;</xsl:text>
        <xsl:value-of select=" eo:ToWrap( $zn:method/zn:summary/text(), '        /// ', 80 ) "/>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        /// &lt;/summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        /// &lt;param name="request"&gt;Request message.&lt;/param&gt;
        /// &lt;returns&gt;Response message.&lt;/returns&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <!-- Code -->
        <xsl:text>        [HttpPost]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        [Route( "api/v1/</xsl:text>
        <xsl:value-of select=" ../@name " />
        <xsl:text>/</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        public async Task&lt;</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Response&gt; </xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>( [FromBody] </xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Request request )</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var impl = new MethodInvoker&lt;</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Implementation,</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Request,</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Response&gt;();</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var context = new ExecutionContext( this.Request ) { Method = "</xsl:text>
        <xsl:value-of select=" ../@name " />
        <xsl:text>/</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>" };</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            return await impl.RunAsync( context, request );</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        }</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template name="rest-get">
        <xsl:param name="ns" />
        <xsl:param name="zn:method" />

        <!-- Documentation -->
        <xsl:text>        /// &lt;summary&gt;</xsl:text>
        <xsl:value-of select=" eo:ToWrap( $zn:method/zn:summary/text(), '        /// ', 80 ) "/>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        /// &lt;/summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:for-each select=" $zn:method/zn:request/* ">
            <xsl:text>        /// &lt;param name="</xsl:text>
            <xsl:value-of select=" @name " />
            <xsl:text>"&gt;</xsl:text>
            <xsl:value-of select=" zn:summary/text() " />
            <xsl:text>&lt;/param&gt;</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:for-each>

        <xsl:text>        /// &lt;returns&gt;Response message.&lt;/returns&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <!-- Code -->
        <xsl:text>        [HttpGet]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        [Route( "api/v1/</xsl:text>
        <xsl:value-of select=" ../@name " />
        <xsl:text>/</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        public async Task&lt;</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Response&gt; </xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>(</xsl:text>

        <!-- Parameters in QS -->
        <xsl:for-each select=" $zn:method/zn:request/* ">
            <xsl:text> [FromUri] </xsl:text>
            <xsl:apply-templates select=" . " mode="type" />
            <xsl:text> </xsl:text>
            <xsl:value-of select=" @name " />

            <xsl:if test=" position() != last() ">
                <xsl:text>,</xsl:text>
            </xsl:if>

            <xsl:if test=" position() = last() ">
                <xsl:text> </xsl:text>
            </xsl:if>
        </xsl:for-each>

        <xsl:text>)</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var request = new </xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Request();</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <!-- Assign over -->
        <xsl:for-each select=" $zn:method/zn:request/* ">
            <xsl:text>            request.</xsl:text>
            <xsl:value-of select=" @name " />
            <xsl:text> = </xsl:text>
            <xsl:value-of select=" @name " />
            <xsl:text>;</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:for-each>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var impl = new MethodInvoker&lt;</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Implementation,</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Request,</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Response&gt;();</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var context = new ExecutionContext( this.Request ) { Method = "</xsl:text>
        <xsl:value-of select=" ../@name " />
        <xsl:text>/</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>" };</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            return await impl.RunAsync( context, request );</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        }</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>


    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ zn:services/zn:method
    ~ WCF service
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:variable name="ucase" select=" 'ABCDEFGHIJKLMNOPQRSTUVWXZY' " />
    <xsl:variable name="lcase" select=" 'abcdefghijklmnopqrstuvwxzy' " />

    <xsl:template match=" zn:service " mode="wcf">
        <xsl:variable name="ns">
            <xsl:value-of select=" ../zn:namespace" />
            <xsl:text>/</xsl:text>
            <xsl:value-of select=" translate( @name, $ucase, $lcase ) " />
        </xsl:variable>

        <!-- Implementation -->
        <xsl:text>    /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>    [ServiceBehavior( Namespace = "</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>    public partial class </xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Services : I</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Services</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:apply-templates select=" zn:method " mode="svc-impl">
            <xsl:with-param name="zn:namespace" select=" $ns " />
            <xsl:sort select=" @name " />
        </xsl:apply-templates>
        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <!-- Contract -->
        <xsl:text>    /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>    [ServiceContract( Namespace = "</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>    public partial interface I</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Services</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:apply-templates select=" zn:method " mode="svc-decl">
            <xsl:with-param name="zn:namespace" select=" $ns " />
            <xsl:sort select=" @name " />
        </xsl:apply-templates>
        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" position() != last() ">
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>

    <xsl:template match=" zn:method " mode="svc-decl">
        <xsl:param name="zn:namespace" />

        <xsl:variable name="ns">
            <xsl:value-of select=" ../@name " />
            <xsl:text>Service</xsl:text>
        </xsl:variable>

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        [OperationContract( Action = "</xsl:text>
        <xsl:value-of select=" $zn:namespace " />
        <xsl:text>/</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>", ReplyAction = "</xsl:text>
        <xsl:value-of select=" $zn:namespace " />
        <xsl:text>/</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Response" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        [FaultContract( typeof( ActorFault ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        [XmlSerializerFormat]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        </xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name" />
        <xsl:text>ResponseContract </xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>( </xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name" />
        <xsl:text>RequestContract request );</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" position() != last() ">
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>

    <xsl:template match=" zn:method " mode="svc-impl">
        <xsl:variable name="ns">
            <xsl:value-of select=" ../@name " />
            <xsl:text>Service</xsl:text>
        </xsl:variable>

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        public </xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name" />
        <xsl:text>ResponseContract </xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>( </xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name" />
        <xsl:text>RequestContract request )</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var impl = new MethodInvoker&lt;</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Implementation,</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Request,</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>Response&gt;();</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var response = new </xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>.</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>ResponseContract();</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            var context = new ExecutionContext( OperationContext.Current ) { Method = "</xsl:text>
        <xsl:value-of select=" ../@name " />
        <xsl:text>/</xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text>" };</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>
            try
            {
                response.Response = impl.RunAsync( context, request.Request ).GetAwaiter().GetResult();
            }
            catch ( ActorException ex )
            {
                throw Soap.ToException( ex );
            }
            catch ( Exception ex )
            {
                throw Soap.ToUnhandledException( ex );
            }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <xsl:text>            return response;</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        }</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" position() != last() ">
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>



    <!-- ================================================================
    ~
    ~ zn:types
    ~ Any shared types XML files *must* be in the same directory as the
    ~ index 'Services.xml' file.
    ~
    ================================================================= -->
    <xsl:template match=" zn:types ">
        <xsl:variable name="zn:services" select=" document( concat( $UriDirectory, '/Services.xml' ) )/zn:services " />

        <xsl:text>// autogenerated: do NOT edit manually / do NOT commit to source control
using Platinum;
using Platinum.Mock;
using Platinum.Validation;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Xml.Serialization;
using System.Web;
using Zinc.WebServices;
using Newtonsoft.Json;

</xsl:text>

        <xsl:text>namespace </xsl:text>
        <xsl:value-of select=" $Namespace " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>{</xsl:text>

        <!-- New types -->
        <xsl:apply-templates select=" * " mode="typedef">
            <xsl:with-param name="ns" select=" $zn:services/zn:namespace/text() " />
        </xsl:apply-templates>

        <xsl:text>}</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>



    <!-- ================================================================
    ~
    ~ zn:method
    ~ Method definition XML files *must* be in a child directory which
    ~ contains the index 'Services.xml' file.
    ~
    ================================================================= -->
    <xsl:template match=" zn:method ">
        <xsl:variable name="zn:services" select=" document( concat( $UriDirectory, '/../Services.xml' ) )/zn:services " />

        <xsl:variable name="service-ns">
            <xsl:value-of select=" $zn:services/zn:namespace/text() " />
            <xsl:text>/</xsl:text>
            <xsl:call-template name="substring-after-last">
                <xsl:with-param name="value" select=" substring( $Namespace, 1, string-length( $Namespace ) - string-length( 'Service' ) ) " />
            </xsl:call-template>
        </xsl:variable>


        <xsl:text>// autogenerated: do NOT edit manually / do NOT commit to source control
using Platinum;
using Platinum.Mock;
using Platinum.Validation;
using System;
using System.Collections.Generic;
using System.Linq;
using System.ServiceModel;
using System.Threading.Tasks;
using System.Xml.Serialization;
using Zinc.WebServices;
using Newtonsoft.Json;
</xsl:text>

        <xsl:for-each select=" zn:using[ @namespace ] ">
            <xsl:text>using </xsl:text>
            <xsl:value-of select=" @namespace " />
            <xsl:text>;</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:for-each>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>namespace </xsl:text>
        <xsl:value-of select=" $Namespace " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>{</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <!-- Request / Wrapper -->
        <xsl:text>    /// &lt;summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// Request contract for method </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// &lt;/summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [MessageContract( IsWrapped = false )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    public class </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>RequestContract</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [MessageHeader( Namespace = "</xsl:text>
        <xsl:value-of select=" $fwk-ns" />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        public EndpointHeader EndpointHeader { get; set; }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [MessageBodyMember( Name = "</xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Request", Namespace = "</xsl:text>
        <xsl:value-of select=" $service-ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        public </xsl:text>
        <xsl:value-of select=" $FileName "/>
        <xsl:text>Request Request { get; set; }</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <!-- Request -->
        <xsl:text>    /// &lt;summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// Request message for method </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// &lt;/summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [XmlType( Namespace = "</xsl:text>
        <xsl:value-of select=" $service-ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [XmlRoot( Namespace = "</xsl:text>
        <xsl:value-of select=" $service-ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:if test=" zn:request/*[ @secret = 'true' ] ">
            <xsl:text>    [HasSecret]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
        <xsl:text>    public class </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Request</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:apply-templates select=" zn:request/* " mode="prop" />
        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <!-- Response / Wrapper -->
        <xsl:text>    /// &lt;summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// Response contract message for method </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// &lt;/summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [MessageContract( IsWrapped = false )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    public class </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>ResponseContract</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [MessageHeader( Namespace = "</xsl:text>
        <xsl:value-of select=" $fwk-ns" />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        public ExecutionHeader ExecutionHeader { get; set; }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [MessageBodyMember( Name = "</xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Response", Namespace = "</xsl:text>
        <xsl:value-of select=" $service-ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        public </xsl:text>
        <xsl:value-of select=" $FileName "/>
        <xsl:text>Response Response { get; set; }</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <!-- Response -->
        <xsl:text>    /// &lt;summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// Response message for method </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    /// &lt;/summary&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [XmlType( Namespace = "</xsl:text>
        <xsl:value-of select=" $service-ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [XmlRoot( Namespace = "</xsl:text>
        <xsl:value-of select=" $service-ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:if test=" zn:response/*[ @secret = 'true' ] ">
            <xsl:text>    [HasSecret]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
        <xsl:text>    public class </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Response</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:apply-templates select=" zn:response/* " mode="prop" />
        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <!-- Implementation -->
        <xsl:call-template name="summary">
            <xsl:with-param name="indent" select=" '    ' " />
        </xsl:call-template>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    public partial class </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Implementation : IMethod&lt;</xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Request, </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Response&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        private ExecutionContext Context { get; set; }</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />

        <xsl:text>        /// &lt;summary /&gt;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        public</xsl:text>
        <xsl:if test=" not( zn:notImplemented ) ">
            <xsl:text> async</xsl:text>
        </xsl:if>
        <xsl:text> Task&lt;</xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Response&gt; RunAsync( ExecutionContext context, </xsl:text>
        <xsl:value-of select=" $FileName " />
        <xsl:text>Request request )</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        {</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>            this.Context = context;</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />
        <xsl:choose>
            <xsl:when test=" zn:notImplemented ">
                <xsl:text>            return Task.FromResult( Mocker.Mock&lt;</xsl:text>
                <xsl:value-of select=" $FileName " />
                <xsl:text>Response&gt;() );</xsl:text>
                <xsl:value-of select=" $NewLine " />
            </xsl:when>
            <xsl:otherwise>
                <xsl:text>            return await InnerRun( request );</xsl:text>
                <xsl:value-of select=" $NewLine " />
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>        }</xsl:text>

        <xsl:value-of select=" $NewLine " />
        <xsl:text>    }</xsl:text>

        <!-- New types -->
        <xsl:apply-templates select=" zn:request/* " mode="typedef">
            <xsl:with-param name="ns" select=" $zn:services/zn:namespace/text() " />
        </xsl:apply-templates>
        <xsl:apply-templates select=" zn:response/* " mode="typedef">
            <xsl:with-param name="ns" select=" $zn:services/zn:namespace/text() " />
        </xsl:apply-templates>

        <xsl:value-of select=" $NewLine " />
        <xsl:text>}</xsl:text>
    </xsl:template>

    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ zn:* / mode=prop
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template match=" zn:* " mode="prop">
        <xsl:call-template name="summary">
            <xsl:with-param name="indent" select=" '        ' " />
        </xsl:call-template>
        <xsl:value-of select=" $NewLine " />
        <xsl:apply-templates select=" . " mode="type-attr" />
        <xsl:apply-templates select=" . " mode="mock-attr" />
        <xsl:if test=" @secret = 'true' ">
            <xsl:text>        [Secret]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
        <xsl:apply-templates select=" @v:* | v:* " mode="valn-attr" />
        <xsl:text>        public </xsl:text>
        <xsl:apply-templates select=" . " mode="type" />
        <xsl:text> </xsl:text>
        <xsl:value-of select=" @name " />
        <xsl:text> { get; set; }</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" position() != last() ">
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>

    <xsl:template match=" zn:summary " mode="prop" />
    <xsl:template match=" zn:remarks " mode="prop" />


    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ zn:* / mode=typedef
    ~ Responsible for emitting the explicitly defined custom types.
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template match=" * " mode="typedef" />

    <xsl:template match=" zn:enumeration " mode="typedef">
        <xsl:param name="ns" select=" 'urn:undefined' " />

        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />
        <xsl:call-template name="summary">
            <xsl:with-param name="indent" select=" '    ' " />
        </xsl:call-template>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [XmlType( Namespace = "</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" @flags = 'true' ">
            <xsl:text>    [Flags]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>

        <xsl:text>    public enum </xsl:text>
        <xsl:value-of select=" @type " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <xsl:if test=" @flags = 'true' ">
            <xsl:text>        /// &lt;summary /&gt;
        None = 0,

</xsl:text>
        </xsl:if>

        <xsl:for-each select=" zn:enum ">
            <xsl:call-template name="summary">
                <xsl:with-param name="indent" select=" '        ' " />
            </xsl:call-template>
            <xsl:value-of select=" $NewLine " />

            <xsl:text>        </xsl:text>
            <xsl:value-of select=" @value "/>

            <xsl:if test=" ../@flags = 'true' ">
                <xsl:text> = </xsl:text>

                <xsl:choose>
                    <xsl:when test=" position() =  1 ">1</xsl:when>
                    <xsl:when test=" position() =  2 ">2</xsl:when>
                    <xsl:when test=" position() =  3 ">4</xsl:when>
                    <xsl:when test=" position() =  4 ">8</xsl:when>
                    <xsl:when test=" position() =  5 ">16</xsl:when>
                    <xsl:when test=" position() =  6 ">32</xsl:when>
                    <xsl:when test=" position() =  7 ">64</xsl:when>
                    <xsl:when test=" position() =  8 ">128</xsl:when>
                    <xsl:when test=" position() =  9 ">256</xsl:when>
                    <xsl:when test=" position() = 10 ">512</xsl:when>
                    <xsl:when test=" position() = 11 ">1024</xsl:when>
                    <xsl:when test=" position() = 12 ">2048</xsl:when>
                </xsl:choose>
            </xsl:if>

            <xsl:text>,</xsl:text>

            <xsl:if test=" position() != last() ">
                <xsl:value-of select=" $NewLine " />
                <xsl:value-of select=" $NewLine " />
            </xsl:if>
        </xsl:for-each>

        <xsl:value-of select=" $NewLine " />
        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:structure " mode="typedef">
        <xsl:param name="ns" select=" 'urn:undefined' " />

        <xsl:value-of select=" $NewLine " />
        <xsl:value-of select=" $NewLine " />
        <xsl:call-template name="summary">
            <xsl:with-param name="indent" select=" '    ' " />
        </xsl:call-template>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    [XmlType( Namespace = "</xsl:text>
        <xsl:value-of select=" $ns " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:if test=" ./*[ @secret = 'true' ] ">
            <xsl:text>    [HasSecret]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
        <xsl:text>    public class </xsl:text>
        <xsl:value-of select=" @type " />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    {</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:apply-templates select=" ./* " mode="prop" />
        <xsl:value-of select=" $NewLine " />
        <xsl:text>    }</xsl:text>
        <xsl:value-of select=" $NewLine " />

        <!-- Recurse: new types -->
        <xsl:apply-templates select=" * " mode="typedef">
            <xsl:with-param name="ns" select=" $ns " />
        </xsl:apply-templates>
    </xsl:template>



    <!-- ================================================================
    ~
    ~ Library!
    ~
    ================================================================= -->

    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ zn:* / mode=type
    ~ Responsible for emitting the .NET type, be it a native CLR type or
    ~ a custom defined type.
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template match=" * " mode="type">
        <xsl:text>undef /*</xsl:text>
        <xsl:value-of select=" local-name(.) " />
        <xsl:text> */</xsl:text>
    </xsl:template>

    <xsl:template name="type-native">
        <xsl:choose>
            <xsl:when test=" @array = 'true' ">
                <xsl:text>[]</xsl:text>
            </xsl:when>
            <xsl:when test=" @optional = 'true' ">
                <xsl:text>?</xsl:text>
            </xsl:when>
        </xsl:choose>
    </xsl:template>

    <xsl:template match=" zn:bool " mode="type">
        <xsl:text>bool</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:binary " mode="type">
        <xsl:text>byte[]</xsl:text>
    </xsl:template>

    <xsl:template match=" zn:char " mode="type">
        <xsl:text>char</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:string " mode="type">
        <xsl:text>string</xsl:text>

        <xsl:if test=" @array = 'true' ">
            <xsl:text>[]</xsl:text>
        </xsl:if>
    </xsl:template>

    <xsl:template match=" zn:short " mode="type">
        <xsl:text>short</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:int | zn:integer " mode="type">
        <xsl:text>int</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:long " mode="type">
        <xsl:text>long</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:float " mode="type">
        <xsl:text>float</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:double " mode="type">
        <xsl:text>double</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:decimal " mode="type">
        <xsl:text>decimal</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:date | zn:dateTime | zn:time " mode="type">
        <xsl:text>DateTime</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>
    
    <xsl:template match=" zn:duration " mode="type">
        <xsl:text>Duration</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:guid " mode="type">
        <xsl:text>Guid</xsl:text>
        <xsl:call-template name="type-native" />
    </xsl:template>

    <xsl:template match=" zn:binary " mode="type">
        <xsl:text>byte[]</xsl:text>
    </xsl:template>

    <xsl:template match=" zn:enumeration | zn:enumeration-ref " mode="type">
        <xsl:value-of select=" @type " />

        <xsl:if test=" @optional = 'true' ">
            <xsl:text>?</xsl:text>
        </xsl:if>
    </xsl:template>

    <xsl:template match=" zn:structure | zn:structure-ref " mode="type">
        <xsl:value-of select=" @type " />

        <xsl:if test=" @array = 'true' ">
            <xsl:text>[]</xsl:text>
        </xsl:if>
    </xsl:template>



    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ zn:* / mode=type-attr
    ~ Responsible for returning all .NET attributes which need to markup
    ~ a property of the given type.
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template match=" * " mode="type-attr" />

    <xsl:template match=" zn:date " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.DateConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [XmlElement( DataType = "date" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:date[ @optional = 'true' ] " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.NullableDateConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [XmlElement( DataType = "date" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:date[ @array = 'true' ] " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.NullableDateConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [XmlArrayItem( DataType = "date" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:duration " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.DurationConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:duration[ @optional = 'true' ] " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.NullableDurationConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:string[ not( @optional = 'true' ) ] " mode="type-attr">
        <xsl:text>        [Required]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:structure[ not( @optional = 'true' ) ] 
                        | zn:structure-ref[ not( @optional = 'true' ) ] " mode="type-attr">
        <xsl:text>        [Required]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:time " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.TimeConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [XmlElement( DataType = "time" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:time[ @optional = 'true' ] " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.NullableTimeConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [XmlElement( DataType = "time" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" zn:time[ @array = 'true' ] " mode="type-attr">
        <xsl:text>        [JsonConverter( typeof( Zinc.Json.NullableTimeConverter ) )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
        <xsl:text>        [XmlArrayItem( DataType = "time" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>


    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ zn:* / mode=mock-attr
    ~ Markup for mocking.
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template match=" * " mode="mock-attr" />

    <xsl:template match=" *[ @mock:data ] " mode="mock-attr" xmlns:mock="urn:zinc/mock">
        <xsl:text>        [MockData( "</xsl:text>
        <xsl:value-of select=" @mock:data " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>


    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ v:* / mode=valn-attr
    ~ For fields which have validations, emit them!
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template match=" @v:rule " mode="valn-attr">
        <xsl:text>        [Rule( "</xsl:text>
        <xsl:value-of select=" @v:rule" />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <!-- String -->
    <xsl:template match=" v:email " mode="valn-attr">
        <xsl:text>        [Email]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" v:length[ @min and not( @max ) ] " mode="valn-attr">
        <xsl:text>        [MinLength( </xsl:text>
        <xsl:value-of select=" @min " />
        <xsl:text> )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" v:length[ not( @min ) and @max ] " mode="valn-attr">
        <xsl:text>        [MaxLength( </xsl:text>
        <xsl:value-of select=" @max " />
        <xsl:text> )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" v:length[ @min and @max ] " mode="valn-attr">
        <xsl:text>        [StringLength( </xsl:text>
        <xsl:value-of select=" @min " />
        <xsl:text>, </xsl:text>
        <xsl:value-of select=" @max " />
        <xsl:text> )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <xsl:template match=" v:regex " mode="valn-attr">
        <xsl:text>        [RegularExpression( @"</xsl:text>
        <xsl:value-of select=" @pattern " />
        <xsl:text>" )]</xsl:text>
        <xsl:value-of select=" $NewLine " />
    </xsl:template>

    <!-- Numerical -->
    <xsl:template match=" v:digits " mode="valn-attr">
        <xsl:if test=" @total ">
            <xsl:text>        [TotalDigits( </xsl:text>
            <xsl:value-of select=" @total " />
            <xsl:text> )]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>

        <xsl:if test=" @decimal ">
            <xsl:text>        [DecimalDigits( </xsl:text>
            <xsl:value-of select=" @decimal " />
            <xsl:text> )]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>

    <xsl:template match=" v:range " mode="valn-attr">
        <xsl:if test=" @minInclusive ">
            <xsl:text>        [MinValue( "</xsl:text>
            <xsl:value-of select=" @minInclusive " />
            <xsl:text>" )]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>

        <xsl:if test=" @minExclusive ">
            <xsl:text>        [MinValue( "</xsl:text>
            <xsl:value-of select=" @minExclusive " />
            <xsl:text>", IsExclusive = true )]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>

        <xsl:if test=" @maxInclusive ">
            <xsl:text>        [MaxValue( "</xsl:text>
            <xsl:value-of select=" @maxInclusive " />
            <xsl:text>" )]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>

        <xsl:if test=" @maxExclusive ">
            <xsl:text>        [MaxValue( "</xsl:text>
            <xsl:value-of select=" @maxExclusive " />
            <xsl:text>", IsExclusive = true )]</xsl:text>
            <xsl:value-of select=" $NewLine " />
        </xsl:if>
    </xsl:template>



    <!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    ~
    ~ Functions
    ~
    ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ -->
    <xsl:template name="substring-after-last">
        <xsl:param name="value"  />
        <xsl:param name="separator" select=" '.' " />

        <xsl:choose>
            <xsl:when test=" contains( $value, $separator ) ">
                <xsl:call-template name="substring-after-last">
                    <xsl:with-param name="value" select=" substring-after( $value, $separator ) " />
                    <xsl:with-param name="separator" select=" $separator " />
                </xsl:call-template>
            </xsl:when>

            <xsl:otherwise>
                <xsl:value-of select=" $value " />
            </xsl:otherwise>
        </xsl:choose>
    </xsl:template>

    <xsl:template name="summary">
        <xsl:param name="indent" />

        <xsl:choose>
            <xsl:when test=" zn:summary ">
                <xsl:value-of select=" $indent " />
                <xsl:text>/// &lt;summary&gt;</xsl:text>
                <!-- This new line not needed! -->

                <xsl:value-of select=" eo:ToWrap( zn:summary/text(), concat( $indent, '/// ' ), 80 ) "/>
                <xsl:text>
</xsl:text>

                <xsl:value-of select=" $indent " />
                <xsl:text>/// &lt;/summary&gt;</xsl:text>
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select=" $indent " />
                <xsl:text>/// &lt;summary /&gt;</xsl:text>
            </xsl:otherwise>
        </xsl:choose>

    </xsl:template>


</xsl:stylesheet>
